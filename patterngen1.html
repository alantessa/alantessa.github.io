---
layout: default
title:  pattern generator 1
---

<div class="svg_wrap"><svg></svg></div>

<ul class="controls">
	<li>
		<button onclick="drawRandom()">draw random</button>
	</li>
	<li>
		<button onclick="redrawPattern()">redraw</button>
		<button onclick="recolorPattern()">recolor</button>
	</li>
	<li class="sides">
		<input class="input" type="range" min="5" max="12">
		<span><span class="result"></span> 각형</span>
	</li>
	<li class="leng">
		<input class="input" type="range" min="10" max="200" step="1">
		<span>크기 <span class="result"></span></span>
	</li>
	<li class="fill">
		<input class="input" type="radio" name="style"><span style="margin-left: 0.5rem">fill</span>
	</li>
	<li class="stroke">
		<input class="input" type="radio" name="style"><span style="margin-left: 0.5rem">stroke</span>
	</li>
	<li class="strokeWidth">
		<input class="input" type="range" min="1" max="100" step="1">
		<span>stroke-width <span class="result"></span></span>
	</li>
	<li class="dashed">
		<input class="input" type="checkbox"><span style="margin-left: 0.5rem">dashed</span>
	</li>
	<li class="ellipse">
		<input class="input" type="radio" name="shape"><span style="margin-left: 0.5rem">ellipse</span>
	</li>
	<li class="rect">
		<input class="input" type="radio" name="shape"><span style="margin-left: 0.5rem">rect</span>
	</li>
	<li class="hue">
		<input class="input" type="range" min="0" max="360" step="1">
		<span>hue <span class="result"></span></span>
	</li>
	<li class="saturation">
		<input class="input" type="range" min="0" max="100" step="1">
		<span>saturation <span class="result"></span></span>
	</li>
	<li class="lightness">
		<input class="input" type="range" min="0" max="100" step="1">
		<span>lightness <span class="result"></span></span>
	</li>
	<li class="bghue">
		<input class="input" type="range" min="0" max="360" step="1">
		<span>bg hue <span class="result"></span></span>
	</li>
	<li class="bgsat">
		<input class="input" type="range" min="0" max="100" step="1">
		<span>bg saturation <span class="result"></span></span>
	</li>
	<li class="bglit">
		<input class="input" type="range" min="0" max="100" step="1">
		<span>bg lightness <span class="result"></span></span>
	</li>
	<li>
		<button onclick="savePattern()">save current pattern</button>
	</li>
</ul>

<script type="text/javascript" src="/js/d3.min.js"></script>
<script type="text/javascript" src="/js/seedrandom.min.js"></script>

<script>
var svgw = 700;
var svgh = 600;
var cfg;
var clrcfg;
var pcfg;

var controls = {
	sides: [document.querySelector('li.sides .input'), document.querySelector('li.sides .result')],
	leng: [document.querySelector('li.leng .input'), document.querySelector('li.leng .result')],
	fill: [document.querySelector('li.fill .input')],
	stroke: [document.querySelector('li.stroke .input')],
	strokeWidth: [document.querySelector('li.strokeWidth .input'), document.querySelector('li.strokeWidth .result')],
	dashed: [document.querySelector('li.dashed .input')],
	ellipse: [document.querySelector('li.ellipse .input')],
	rect: [document.querySelector('li.rect .input')],
	hue: [document.querySelector('li.hue .input'), document.querySelector('li.hue .result')],
	saturation: [document.querySelector('li.saturation .input'), document.querySelector('li.saturation .result')],
	lightness: [document.querySelector('li.lightness .input'), document.querySelector('li.lightness .result')],
	bghue: [document.querySelector('li.bghue .input'), document.querySelector('li.bghue .result')],
	bgsat: [document.querySelector('li.bgsat .input'), document.querySelector('li.bgsat .result')],
	bglit: [document.querySelector('li.bglit .input'), document.querySelector('li.bglit .result')],
}

function main() {
	drawRandom();
	changeAsControlledValue();
}

var _trigger;
function triggerRedraw() {
	if(_trigger) {
		window.clearTimeout(_trigger);
	}
	_trigger = window.setTimeout(redraw, 100);
}

function redraw() {
	setTemplate();
	drawTiles();
	colorPattern();
	setControlValue();
}

function drawRandom() {
	cfg = {
		sides: 6,
		leng: Math.floor(Math.random() * 150) + 30,
		fill: false,
		stroke: false,
		strokeWidth: Math.floor(Math.random() * 99) + 1,
		dashed: false,
	};

	clrcfg = {
		hue: Math.floor(Math.random() * 360),
		saturation: Math.floor(Math.random() * 80 + 10),
		lightness: Math.floor(Math.random() * 80 + 10),
		bghue: Math.floor(Math.random() * 360),
		bgsat: Math.floor(Math.random() * 80 + 10),
		bglit: Math.floor(Math.random() * 80 + 10),
	}

	pcfg = {
		ellipse: false,
		cx: Math.random(),
		cy: Math.random(),
		rx: Math.random(),
		ry: Math.random(),
		rect: false,
		x: Math.random(),
		y: Math.random(),
		width: Math.random(),
		height: Math.random(),
	}

	if (Math.random() <= 0.5) {
		cfg.fill = true;
	} else {
		cfg.stroke = true;
	}

	if (Math.random() <= 0.5) {
		cfg.dashed = true;
	} 

	if (Math.random() <= 0.5) {
		pcfg.ellipse = true;
	} else {
		pcfg.rect = true;
	}

	redraw();
}

function setTemplate() {
	var svg = d3.select('svg');
	svg.selectAll('*').remove();

	var template = svg.append('g');
	var tile = template.append('g');
	var mask = template.append('defs').append('mask');
	var maskshape = mask.append('polygon');

	svg
		.attr('width', svgw)
		.attr('height', svgh)
		.attr('shape-rendering', 'geometricPrecision')
	template
		.style('display', 'none');
	tile
		.attr('id', 'tile')
		.style('mask', 'url(#mask)');
	mask
		.attr('id', 'mask')
		.attr('x', 0)
		.attr('y', 0);
	maskshape
		.attr('id', 'maskshape')
		.style('fill', '#FFF');
}

function drawTiles() {
	var angle = 2 * Math.PI / cfg.sides;
	var tilew = cfg.leng;
	var tileh = Math.sin(angle * 2) * cfg.leng;

	// draw mask
	var points = []
	var pointx = 0;
	var pointy = 0;
	for (var i = 0; i < 3; i++) {
		points.push(pointx + ',' + pointy);
		pointx = Math.cos(i * angle) * cfg.leng;
		pointy = Math.sin(i * angle) * cfg.leng;
	}
	var mask = d3.select('#mask');
	mask
		.attr('width', tilew)
		.attr('height', tileh);

	var maskshape = d3.select('#maskshape');
	maskshape
		.attr('points', points[0] + ' ' + points[1] + ' ' + points[2]);

	layTiles(d3.select('svg'), svgw, svgh, tilew, tileh, cfg.sides, angle);
	drawPattern(tilew, tileh);
}

function layTiles(svg, svgw, svgh, tilew, tileh, sides, angle) {
	var data = [];

	for(var i = 0; i < Math.ceil(svgw / tilew); i++) {
		var even = i % 2 == 0;
		var xvar = even ? 3 * (i / 2) : 3 * ((i + 1) / 2) - 1.5;
		var anglenum = angle / Math.PI * 180;

		for(var j = 0; j < Math.ceil(svgh / tileh); j++) {
			var yvar = even ? j * 2 : (j * 2) + 1;

			for(var k = 0; k < sides; k++) {
				data.push({
					x: tilew * xvar,
					y: tileh * yvar,
					a: k * anglenum
				});
			}
		}
	}

	var uses = svg.selectAll('use').data(data);
	uses.enter()
		.append('use')
		.attr('x', function(d) {return d.x;})
		.attr('y', function(d) {return d.y;})
		.attr('xlink:href', '#tile')
		.attr('transform', function(d) {return 'rotate(' + d.a + ',' + d.x + ',' + d.y + ')';});
}

function drawPattern(tilew, tileh) {
	if (pcfg.ellipse) {
		var pattern = d3.select('#tile').append('ellipse')
			pattern
				.attr('cx', Math.floor(pcfg.cx * tilew))
				.attr('cy', Math.floor(pcfg.cy * tileh))
				.attr('rx', Math.ceil(pcfg.rx * tilew))
				.attr('ry', Math.ceil(pcfg.ry * tileh));
	}

	if (pcfg.rect) {
		var pattern = d3.select('#tile').append('rect')
			pattern
				.attr('x', Math.floor(pcfg.x * tilew / 2))
				.attr('y', Math.floor(pcfg.y * tileh / 2))
				.attr('width', Math.ceil(pcfg.width * tilew))
				.attr('height', Math.ceil(pcfg.height * tileh));
	}

	var color = 'hsla(' + clrcfg.hue + ',' + clrcfg.saturation + '%,' + clrcfg.lightness + '%, 1)';
	if (cfg.fill) {
		pattern.attr('fill', color);
	} else { pattern.attr('fill', 'transparent') };

	if (cfg.stroke) {
		pattern
			.attr('stroke', color)
			.attr('stroke-width', Math.floor(cfg.strokeWidth * 0.01 * Math.min(tileh, tilew)));
	};
	if (cfg.dashed) {
		pattern.attr('stroke-dasharray', '5, 5');
	};
}

function colorPattern() {
	bgcolor = 'hsla(' + clrcfg.bghue + ',' + clrcfg.bgsat + '%,' + clrcfg.bglit + '%, 1)';
	d3.select('svg').style('background-color', bgcolor);
}

function redrawPattern() {
	pcfg.cx = Math.random();
	pcfg.cy = Math.random();
	pcfg.rx = Math.random();
	pcfg.ry = Math.random();
	pcfg.x = Math.random();
	pcfg.y = Math.random();
	pcfg.width = Math.random();
	pcfg.height = Math.random();

	redraw();
}

function recolorPattern() {
	clrcfg.hue = Math.floor(Math.random() * 360),
	clrcfg.saturation = Math.floor(Math.random() * 80 + 10);
	clrcfg.lightness = Math.floor(Math.random() * 80 + 10);
	clrcfg.bghue = Math.floor(Math.random() * 360);
	clrcfg.bgsat = Math.floor(Math.random() * 80 + 10);
	clrcfg.bglit = Math.floor(Math.random() * 80 + 10);

	redraw();
}

function setControlValue() {
	controls.sides[0].value = controls.sides[1].innerHTML = cfg.sides;
	controls.leng[0].value = controls.leng[1].innerHTML = cfg.leng;
	controls.strokeWidth[0].value = controls.strokeWidth[1].innerHTML = cfg.strokeWidth;
	controls.fill[0].checked = cfg.fill;
	controls.stroke[0].checked = cfg.stroke;
	controls.dashed[0].checked = cfg.dashed;
	controls.ellipse[0].checked = pcfg.ellipse;
	controls.rect[0].checked = pcfg.rect;
	controls.hue[0].value = controls.hue[1].innerHTML = clrcfg.hue;
	controls.saturation[0].value = controls.saturation[1].innerHTML = clrcfg.saturation;
	controls.lightness[0].value = controls.lightness[1].innerHTML = clrcfg.lightness;
	controls.bghue[0].value = controls.bghue[1].innerHTML = clrcfg.bghue;
	controls.bgsat[0].value = controls.bgsat[1].innerHTML = clrcfg.bgsat;
	controls.bglit[0].value = controls.bglit[1].innerHTML = clrcfg.bglit;
}

function changeAsControlledValue() {
	var svg = d3.select('svg');
	controls.sides[0].addEventListener('input', function() {
		controls.sides[1].innerHTML = cfg.sides = controls.sides[0].value;
		triggerRedraw();
	});
	controls.leng[0].addEventListener('input', function() {
		controls.leng[1].innerHTML = cfg.leng = controls.leng[0].value;
		triggerRedraw();
	});
	controls.fill[0].addEventListener('change', function() {
		cfg.fill = controls.fill[0].checked;
		cfg.stroke = controls.stroke[0].checked;

		if (controls.stroke[0].checked) {
			controls.strokeWidth[0].disabled = false;
			controls.dashed[0].disabled = false;
		} else {
			controls.strokeWidth[0].disabled = true;
			controls.dashed[0].disabled = true;
		}
		triggerRedraw();
	});
	controls.stroke[0].addEventListener('change', function() {
		cfg.fill = controls.fill[0].checked;
		cfg.stroke = controls.stroke[0].checked;

		if (controls.stroke[0].checked) {
			controls.strokeWidth[0].disabled = false;
			controls.dashed[0].disabled = false;
		} else {
			controls.strokeWidth[0].disabled = true;
			controls.dashed[0].disabled = true;
		}
		triggerRedraw();
	});
	controls.strokeWidth[0].addEventListener('input', function() {
		controls.strokeWidth[1].innerHTML = cfg.strokeWidth = controls.strokeWidth[0].value;
		triggerRedraw();
	});
	controls.dashed[0].addEventListener('change', function() {
		cfg.dashed = controls.dashed[0].checked;
		triggerRedraw();
	});
	controls.ellipse[0].addEventListener('change', function() {
		pcfg.ellipse = controls.ellipse[0].checked;
		pcfg.rect = controls.rect[0].checked;
		triggerRedraw();
	});
	controls.rect[0].addEventListener('change', function() {
		pcfg.ellipse = controls.ellipse[0].checked;
		pcfg.rect = controls.rect[0].checked;
		triggerRedraw();
	});
	controls.hue[0].addEventListener('input', function() {
		controls.hue[1].innerHTML = clrcfg.hue = controls.hue[0].value;
		triggerRedraw();
	});
	controls.saturation[0].addEventListener('input', function() {
		controls.saturation[1].innerHTML = clrcfg.saturation = controls.saturation[0].value;
		triggerRedraw();
	});
	controls.lightness[0].addEventListener('input', function() {
		controls.lightness[1].innerHTML = clrcfg.lightness = controls.lightness[0].value;
		triggerRedraw();
	});
	controls.bghue[0].addEventListener('input', function() {
		controls.bghue[1].innerHTML = clrcfg.bghue = controls.bghue[0].value;
		triggerRedraw();
	});
	controls.bgsat[0].addEventListener('input', function() {
		controls.bgsat[1].innerHTML = clrcfg.bgsat = controls.bgsat[0].value;
		triggerRedraw();
	});
	controls.bglit[0].addEventListener('input', function() {
		controls.bglit[1].innerHTML = clrcfg.bglit = controls.bglit[0].value;
		triggerRedraw();
	});
}

function savePattern() {
	var img = document.createElement('img');
	var svgSrc = d3.select('.svg_wrap svg')
		.attr('version', '1.1')
		.attr('xmlns', 'http://www.w3.org/2000/svg')
		.node().parentNode.innerHTML;
	img.src = 'data:image/svg+xml;base64,'+ btoa(svgSrc);
	img.addEventListener('load', function() {
		var canvas = document.createElement('canvas');
		canvas.width = img.width * 4;
		canvas.height = img.height * 4;
		var ctx = canvas.getContext('2d');
		ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width * 10, img.height * 10);
		var pngData = canvas.toDataURL('image/png');

		var a = document.createElement("a");
		a.download = "pattern_" + d3.time.format('%Y%m%d%H%M%S%L')(new Date()) + ".png";
		a.href = pngData;
		a.click();
	});
}

window.addEventListener('load', main);

</script>
