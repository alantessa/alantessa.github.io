---
layout: post
title:  "svg use"
thumbnail: "draft.png"
---

<article class="post">
	<div class="frame" style="display: none;">
		<canvas class="draw-target"></canvas>
	</div>
	<div style="background-color: #FFF; position: absolute; right: 0; width: 600px;">
		<ul style="margin: 0 0 2em; padding:0;">
			<li style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<button onclick="redrawPattern()">redraw pattern</button>
			</li>
			<li style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<button onclick="drawRandom()">draw random</button>
			</li>
			<li class="sides" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
	  		<input class="input" type="range" min="5" max="12">
				<span><span class="result"></span> 각형</span>
			</li>
			<li class="leng" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
	  		<input class="input" type="range" min="10" max="200" step="1">
				<span>크기 <span class="result"></span></span>
			</li>
		</ul>
		<ul style="margin: 0 0 2em; padding:0;">
			<li class="alpha" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="range" min="0" max="1" step="0.05">
				<span>alpha <span class="result"></span></span>
			</li>
			<li class="hue" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="range" min="0" max="360" step="1">
				<span>hue <span class="result"></span></span>
			</li>
			<li class="saturation" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="range" min="0" max="100" step="1">
				<span>saturation <span class="result"></span></span>
			</li>
			<li class="lightness" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="range" min="0" max="100" step="1">
				<span>lightness <span class="result"></span></span>
			</li>
		</ul>
		<ul style="margin: 0 0 2em; padding:0;">
			<li class="fill" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="radio" name="style"><span style="margin-left: 0.5rem">fill</span>
			</li>
			<li class="stroke" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="radio" name="style"><span style="margin-left: 0.5rem">stroke</span>
			</li>
			<li class="strokeWidth" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="range" min="1" max="100" step="1">
				<span>stroke-width <span class="result"></span></span>
			</li>
			<li class="dashed" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="checkbox"><span style="margin-left: 0.5rem">dashed</span>
			</li>
		</ul>
		<ul style="margin: 0 0 2em; padding:0;">
			<li class="ellipse" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="radio" name="shape"><span style="margin-left: 0.5rem">ellipse</span>
			</li>
			<li class="rect" style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<input class="input" type="radio" name="shape"><span style="margin-left: 0.5rem">rect</span>
			</li>
			<!-- <li style="display: inline-block; margin: 0 1.5rem 1rem 0; width: 240px;">
				<button onclick="getCurDesign()">get current design</button>
			</li> -->
		</ul>
	</div>
	<svg></svg>
</article>

<script>
var svgw = 800;
var svgh = 800;
var cfg;
var pcfg;

var controls = {
	sides: [document.querySelector('li.sides .input'), document.querySelector('li.sides .result')],
	leng: [document.querySelector('li.leng .input'), document.querySelector('li.leng .result')],
	alpha: [document.querySelector('li.alpha .input'), document.querySelector('li.alpha .result')],
	hue: [document.querySelector('li.hue .input'), document.querySelector('li.hue .result')],
	saturation: [document.querySelector('li.saturation .input'), document.querySelector('li.saturation .result')],
	lightness: [document.querySelector('li.lightness .input'), document.querySelector('li.lightness .result')],
	fill: [document.querySelector('li.fill .input')],
	stroke: [document.querySelector('li.stroke .input')],
	strokeWidth: [document.querySelector('li.strokeWidth .input'), document.querySelector('li.strokeWidth .result')],
	dashed: [document.querySelector('li.dashed .input')],
	ellipse: [document.querySelector('li.ellipse .input')],
	rect: [document.querySelector('li.rect .input')],
}

function init(ctx, w, h) {
	drawRandom();
	changeAsControlledValue();
}

var _trigger;
function triggerRedraw() {
	if(_trigger) {
		window.clearTimeout(_trigger);
	}
	_trigger = window.setTimeout(redraw, 100);
}

function redraw() {
	setTemplate();
	drawTiles();
	setControlValue();
}

function drawRandom() {
	cfg = {
		sides: 6,
		leng: Math.floor(Math.random() * 150) + 30,
		alpha: 1,
		hue: Math.floor(Math.random() * 360),
		saturation: Math.floor(Math.random() * 80 + 10),
		lightness: Math.floor(Math.random() * 80 + 10),
		fill: false,
		stroke: true,
		strokeWidth: Math.floor(Math.random() * 99) + 1,
		dashed: false,
	};

	pcfg = {
		ellipse: true,
		cx: Math.random(),
		cy: Math.random(),
		rx: Math.random(),
		ry: Math.random(),
		rect: false,
		x: Math.random(),
		y: Math.random(),
		width: Math.random(),
		height: Math.random(),
	}

	redraw();
}

function setTemplate() {
	var svg = d3.select('svg');
	svg.selectAll('*').remove();

	var template = svg.append('g');
	var tile = template.append('g');
	var mask = template.append('defs').append('mask');
	var maskshape = mask.append('polygon');

	svg
		.attr('width', svgw)
		.attr('height', svgh)
		.attr('shape-rendering', 'geometricPrecision')
		.style('border', '1px solid #AAA');
	template
		.style('display', 'none');
	tile
		.attr('id', 'tile')
		.style('mask', 'url(#mask)');
	mask
		.attr('id', 'mask')
		.attr('x', 0)
		.attr('y', 0);
	maskshape
		.attr('id', 'maskshape')
		.style('fill', '#FFF');
}

function drawTiles() {
	var angle = 2 * Math.PI / cfg.sides;
	var tilew = cfg.leng;
	var tileh = Math.sin(angle * 2) * cfg.leng;

	// draw mask
	var points = []
	var pointx = 0;
	var pointy = 0;
	for (var i = 0; i < 3; i++) {
		points.push(pointx + ',' + pointy);
		pointx = Math.cos(i * angle) * cfg.leng;
		pointy = Math.sin(i * angle) * cfg.leng;
	}
	var mask = d3.select('#mask');
	mask
		.attr('width', tilew)
		.attr('height', tileh);

	var maskshape = d3.select('#maskshape');
	maskshape
		.attr('points', points[0] + ' ' + points[1] + ' ' + points[2]);

	layTiles(d3.select('svg'), svgw, svgh, tilew, tileh, cfg.sides, angle);
	drawPattern(tilew, tileh);
}

function layTiles(svg, svgw, svgh, tilew, tileh, sides, angle) {
	var data = [];

	for(var i = 0; i < Math.ceil(svgw / tilew); i++) {
		var even = i % 2 == 0;
		var xvar = even ? 3 * (i / 2) : 3 * ((i + 1) / 2) - 1.5;
		var anglenum = angle / Math.PI * 180;

		for(var j = 0; j < Math.ceil(svgh / tileh); j++) {
			var yvar = even ? j * 2 : (j * 2) + 1;

			for(var k = 0; k < sides; k++) {
				data.push({
					x: tilew * xvar,
					y: tileh * yvar,
					a: k * anglenum
				});
			}
		}
	}

	var uses = svg.selectAll('use').data(data);
	uses.enter()
		.append('use')
		.attr('x', function(d) {return d.x;})
		.attr('y', function(d) {return d.y;})
		.attr('xlink:href', '#tile')
		.attr('transform', function(d) {return 'rotate(' + d.a + ',' + d.x + ',' + d.y + ')';});
}

function drawPattern(tilew, tileh) {
	if (pcfg.ellipse) {
		var pattern = d3.select('#tile').append('ellipse')
			pattern
				.attr('cx', Math.floor(pcfg.cx * tilew))
				.attr('cy', Math.floor(pcfg.cy * tileh))
				.attr('rx', Math.ceil(pcfg.rx * tilew))
				.attr('ry', Math.ceil(pcfg.ry * tileh));
	}

	if (pcfg.rect) {
		var pattern = d3.select('#tile').append('rect')
			pattern
				.attr('x', Math.floor(pcfg.x * tilew / 2))
				.attr('y', Math.floor(pcfg.y * tileh / 2))
				.attr('width', Math.ceil(pcfg.width * tilew))
				.attr('height', Math.ceil(pcfg.height * tileh));
	}

	var color = 'hsla(' + cfg.hue + ',' + cfg.saturation + '%,' + cfg.lightness + '%,' + cfg.alpha + ')';
	if (cfg.fill) {
		pattern.attr('fill', color);
	} else { pattern.attr('fill', 'transparent') };

	if (cfg.stroke) {
		pattern
			.attr('stroke', color)
			.attr('stroke-width', Math.floor(cfg.strokeWidth * 0.01 * Math.min(tileh, tilew)));
	};
	if (cfg.dashed) {
		pattern.attr('stroke-dasharray', '5, 5');
	};
}

function redrawPattern() {
	pcfg.cx = Math.random();
	pcfg.cy = Math.random();
	pcfg.rx = Math.random();
	pcfg.ry = Math.random();
	pcfg.x = Math.random();
	pcfg.y = Math.random();
	pcfg.width = Math.random();
	pcfg.height = Math.random();

	redraw();
}

function setControlValue() {
	controls.sides[0].value = controls.sides[1].innerHTML = cfg.sides;
	controls.leng[0].value = controls.leng[1].innerHTML = cfg.leng;
	controls.alpha[0].value = controls.alpha[1].innerHTML = cfg.alpha;
	controls.hue[0].value = controls.hue[1].innerHTML = cfg.hue;
	controls.saturation[0].value = controls.saturation[1].innerHTML = cfg.saturation;
	controls.lightness[0].value = controls.lightness[1].innerHTML = cfg.lightness;
	controls.strokeWidth[0].value = controls.strokeWidth[1].innerHTML = cfg.strokeWidth;
	controls.fill[0].checked = cfg.fill;
	controls.stroke[0].checked = cfg.stroke;
	controls.dashed[0].checked = cfg.dashed;
	controls.ellipse[0].checked = pcfg.ellipse;
	controls.rect[0].checked = pcfg.rect;
}

function changeAsControlledValue() {
	var svg = d3.select('svg');
	controls.sides[0].addEventListener('input', function() {
		controls.sides[1].innerHTML = cfg.sides = controls.sides[0].value;
		triggerRedraw();
	});
	controls.leng[0].addEventListener('input', function() {
		controls.leng[1].innerHTML = cfg.leng = controls.leng[0].value;
		triggerRedraw();
	});
	controls.alpha[0].addEventListener('input', function() {
		controls.alpha[1].innerHTML = cfg.alpha = controls.alpha[0].value;
		triggerRedraw();
	});
	controls.hue[0].addEventListener('input', function() {
		controls.hue[1].innerHTML = cfg.hue = controls.hue[0].value;
		triggerRedraw();
	});
	controls.saturation[0].addEventListener('input', function() {
		controls.saturation[1].innerHTML = cfg.saturation = controls.saturation[0].value;
		triggerRedraw();
	});
	controls.lightness[0].addEventListener('input', function() {
		controls.lightness[1].innerHTML = cfg.lightness = controls.lightness[0].value;
		triggerRedraw();
	});
	controls.fill[0].addEventListener('change', function() {
		cfg.fill = controls.fill[0].checked;
		cfg.stroke = controls.stroke[0].checked;

		if (controls.stroke[0].checked) {
			controls.strokeWidth[0].disabled = false;
			controls.dashed[0].disabled = false;
		} else {
			controls.strokeWidth[0].disabled = true;
			controls.dashed[0].disabled = true;
		}
		triggerRedraw();
	});
	controls.stroke[0].addEventListener('change', function() {
		cfg.fill = controls.fill[0].checked;
		cfg.stroke = controls.stroke[0].checked;

		if (controls.stroke[0].checked) {
			controls.strokeWidth[0].disabled = false;
			controls.dashed[0].disabled = false;
		} else {
			controls.strokeWidth[0].disabled = true;
			controls.dashed[0].disabled = true;
		}
		triggerRedraw();
	});
	controls.strokeWidth[0].addEventListener('input', function() {
		controls.strokeWidth[1].innerHTML = cfg.strokeWidth = controls.strokeWidth[0].value;
		triggerRedraw();
	});
	controls.dashed[0].addEventListener('change', function() {
		cfg.dashed = controls.dashed[0].checked;
		triggerRedraw();
	});
	controls.ellipse[0].addEventListener('change', function() {
		pcfg.ellipse = controls.ellipse[0].checked;
		pcfg.rect = controls.rect[0].checked;
		triggerRedraw();
	});
	controls.rect[0].addEventListener('change', function() {
		pcfg.ellipse = controls.ellipse[0].checked;
		pcfg.rect = controls.rect[0].checked;
		triggerRedraw();
	});
}

function getCurDesign() {
	var curdesign = {
		sides: cfg.sides,
		leng: cfg.leng,
		alpha: cfg.alpha,
		hue: cfg.hue,
		saturation: cfg.saturation,
		lightness: cfg.lightness,
		fill: cfg.fill,
		stroke: cfg.stroke,
		strokeWidth: cfg.strokeWidth,
		dashed: cfg.dashed,
		ellipse: pcfg.ellipse,
		cx: pcfg.cx,
		cy: pcfg.cy,
		rx: pcfg.rx,
		ry: pcfg.ry,
		rect: pcfg.rect,
		x: pcfg.x,
		y: pcfg.y,
		width: pcfg.width,
		height: pcfg.height,
	}
	console.log(curdesign);
}

</script>
